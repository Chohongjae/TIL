# 다양한 응답의 함수 기반 뷰 만들기

- View
    - 1개의 HTTP 요청에 대해 -> 1개의 뷰가 호출
    - urls.py/urlpatterns 리스트에 매핑된 호출 가능한 객체
        - 함수도 "호출 가능한 객체" 중의 하나
    - 웹 클라이언트로부터의 HTTP 요청을 처리
    - 크게 2가지 형태의 뷰
        - 함수 기반 뷰 (Function Based View) : 장고 뷰의 기본.
            - 호출 가능한 객체. 그 자체
        - 클래스 기반 뷰 (Class Based View)
            - 클래스.as_view() 를 통해 호출가능한 객체를 생성/리턴
            
- View 호출 시, 인자
    - HttpRequest 객체 및 URL Captured Values
    - 1번째 인자 : HttpRequest 객체
        - 현재 요청에 대한 모든 내역을 담고 있습니다.
    - 2번째이후 인자 : 현재 요청의 URL로부터 Capture된 문자열들(ex: shop/"<"int:year">" 에서 year)
        - def view(request, year)
        - url/re_path(장고 1.xx 버젼) 를 통한 처리에서는 -> 모든 인자는 str 타입으로 전달
        - path 를 통한 처리에서는 -> 매핑된 Converter의 to_python에 맞게 변환된 값이 인자로 전달
            - 지난 에피소드의 4자리 년도를 위한 FourDigitYearConverter에서는 int 변환 -> 뷰의 인자로 int 타입의<br>
              년도가 전달
                  
- View 호출에 대한 리턴값
    - HttpResponse 객체
    - 필히 HttpResponse 객체를 리턴해야 합니다.
        - 장고 Middleware에서는 뷰에서 HttpResponse 객체를 리턴하기를 기대합니다. <br>
         -> 다른 타입을 리턴하면 Middleware에서 처리 오류.
        - django.shortcuts.render 함수는 템플릿 응답을 위한 shortcut 함수
    - 파일like객체 혹은 str/bytes 타입의 응답 지원
        - str 문자열을 직접 utf8로 인코딩할 필요가 없습니다.
            - 장고 디폴트 설정에서 str 문자열을 utf8로 인코딩해줍니다.
        - response = HttpResponse( 파일like객체 또는 str객체 또는 bytes객체 ) -> 파일다운로드할때 이렇게?
                
                1) HttpResponse(data)
                2) response = HttpResponse()
                   response.write(data)
                둘중에 한가지 방법 사용
    - 파일 like 객체
        - response.write( str객체 또는 bytes객체 )
        
- Django에서 request를 처리하는 방식
    - url의 부분으로써의 파라미터(Parameters as part of url)
        - request url = users/3<br>
          urls.py -> users/<"int:user_id"><br>
          views.py -> user_id = 3<br>
                
                <fbv>
                def viewname(request, user_id):
                    user = User.objects.get(id=user_id)
                    #do something with this user
                    
                <cbc>
                class SampleView(TemplateView):
                    def get_context_data(self, **kwargs):
                        user = User.objects.get(id=kwargs['user_id'])
                        #do something with this user
                
    - GET 요청 - > request.GET 
          request url = polls/?question_id=3&question_name=test<br>
          urls.py -> polls/<br>
          views.py -> request.GET['question_id'] or request.GET.get('question_id') or<br>
           request.GET['question_name']  
                
                url(r'^products/', 'viewname', name='urlname')
                def viewname(request):
                    price_lte = request.GET['price_lte']
                    #Code to filter products whose price is less than price_lte i.e. 5000
    
    - EX)

            - request url : https://localhost:8000/server/ad-api/test/4?id=3&pw=qwer123
            - django.urls.py : /server/ad-api/test/<int:pk>/                
            - django.views.py
                pk = 4
                request.GET['id'] = 3
                request.GET.get('id') = 3
                request.GET = <QueryDict: {'id': ['3']}>
                request.GET.get('id2', default='7') = 7 (예외처리)
      
    - POST 요청 - > request.POST
        - POST를 처리할때는 클라이언트로부터 넘어오는 데이터 형식에 따라 처리 방식이 달라진다.
        - body에 {} 이러한 형태의 json 타입(application/json)이 넘어오면 request.body로 처리하고
        - body에 id=3&pw=4 식의 &로 구분되는 key=value 형태의 데이터(application/x-www-form-urlencoded)가<br> 
          넘어오면 request.POST로 처리한다.
        
        - request의 content-type에는 application/x-www-form-urlencoded, text/plain multipart/form-data등이 있다.<br>
          POST 방식으로 데이터를 보낼때는 위와 같이 컨텐츠 타입을 꼭 명시해줘야한다.<br>
          보통 작성하지 않는 경우는 application/x-www-form-urlencoded 컨텐츠 타입으로 셋팅된다.<br>
          - application/x-www-form-urlencoded 타입
            - GET방식과 마찬가지로 &로 구분지어지는 key 와 value 쌍 데이터가 전송된다.<br>
              request.POST로 받으면 되고 URL에는 전송되는 데이터가 표시되지 않는다.
            - In general case, url when sending post parameters doesnt contain anything related to<br>
              parameters in the url    
              
                    ex) name_field=Default+name+for+team.&name_field2=Default+name+for+team2.
        
          - application/json 타입
            - content-type이 application/json 이고 BODY에 json형태의 값이 담겨서 넘어오면<br>
              request.body로 받는다. application/json은 대부분의 API에서 활용하는 Content-Type 헤더로써<br>
              HTTP 요청을 하게 되면 body에 담긴 데이터를 서버가 JSON 타입으로 변환(json.loads())해서 사용한다.<br>
              그런데 body에 담긴 값은 byte타입이기 때문에 unicode 형식만 처리할 수 있어서<br>
              json.loads()에 넣기전에 decode('utf-8')로 디코딩을 해주고 json.loads(request.body)로 처리해야 한다.<br>
              일반적인 HTML 폼으로 전송할 때는 x-www-form-urlencoded 또는 multipart/form-data로 전송된다.
        
                    You're confusing form-encoded and JSON data here. <br>
                    request.POST['foo'] is for form-encoded data.<br> 
                    You are posting raw JSON, so you should use request.body.
                    
          - text/plain은, BODY에 단순 txt를 넣는다.<br>
          - multipart/form-data은, 파일전송을 할때 많이 쓰는데 BODY의 데이터를 바이너리 데이터로 넣는다는걸<br>
            알려준다.
        
        - 즉, django에서 클라이언트에서 POST로 넘어온 request를 처리할 때 
        
                content_type이 application/x-www-form-urlencoded 인 경우 request.POST 사용
                content_type이 application/json 인 경우 request.body 사용

    <br><br><br>

# request.data in DRF vs request.body in Django
    Aboout request.data
    REST framework introduces a Request object that extends the regular HttpRequest, 
    and provides more flexible request parsing. 
    The core functionality of the Request object is the request.data attribute, 
    which is similar to request.POST, but more useful for working with Web APIs.
    request.POST # Only handles form data. Only works for 'POST' method.
    request.data # Handles arbitrary data. Works for 'POST', 'PUT' and 'PATCH' methods.

    About request.body
    The raw HTTP request body as a byte string. This is useful for processing data 
    in different ways than conventional HTML forms: binary images, XML payload etc. 
    For processing conventional form data, use HttpRequest.POST.
