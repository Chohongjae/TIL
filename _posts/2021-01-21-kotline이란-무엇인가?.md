---
title: "Kotlin이란 무엇이며 왜 필요한가?"
categories: 
  - kotlin
last_modified_at: 2021-01-21T23:00:00+09:00
---

## 코틀린 기본 기능 데모
    코틀린은 자바 플랫폼에서 돌아가는 새로운 프로그래밍 언어다.
    간결하고 실용적이며, 자바 코드와의 상호운용성을 중시한다.
    현재 자바가 사용중인 곳이라면 대부분 코틀린을 활용할 수 있다.
    
    간단하게 Person이라는 클래스를 정의하고 Person을 모아둔 컬렉션을 만들고
    가장 나이가 많은 사람을 찾아 결과를 출력해보자.
    
    우선 java로 구현해보자.    
    
```java
public class Person {
    private String name;
    private int age;

    public Person(String name) {
        this(name, null);
    }

    public Person(String name, Integer age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public Integer getAge() {
        return age;
    }

    @Override
    public String toString() {
        return "Person(name=" + name + ", age=" + age + ")";
    }

    public static void main(String[] args) {
        List<Person> persons = Arrays.asList(new Person("영희"), new Person("철수", 20));
        Person oldestPerson = persons.stream().max(Comparator.comparingInt(Person::getAge)).orElseThrow();
        System.out.println("나이가 가장 많은 사람: " + oldestPerson);
    }
}
```

{% raw %} <img src="https://chohongjae.github.io/assets/img/20210121코틀린이란무엇인가/javaresult.png" alt=""> {% endraw %}

    매우 긴 것을 확인할 수 있다.
    이번에는 코틀린으로 구현해보자.
    

```kotlin
data class Person(val name: String, val age: Int? = null) // 데이터 클래스, 널이될 수 있는 타입과 디폴트 값

fun main(args: Array<String>) { // 최사우이 함수
    val persons = listOf(Person("영희"), Person("철수", age = 20)) // 이름붙은 파라미터
    val oldest = persons.maxByOrNull { it.age ?: 0 } // 람다식과 엘비스 연산자
    println("나이가 가장 많은 사람: $oldest") // 엘비스 템플릿
}
```

    name과 age라는 프로퍼티가 들어간 간단한 데이터 클래스를 정의한다.
    age 의 기본 값은 null이다.
    엘비스 연산자라고 불리는 ?:는 age가 null인 경우 0을 반환하고, 그렇지 않은 경우 age의 값을 반환한다.
    
    이처럼 코틀린은 자바보다 더 간결하게 작성할 수 있다는 장점이 있다.
    
## 코틀린의 주요 특성
    코틀린의 주목적은 현재 자바가 사용되고 있는 모든 용도에 적합하면서 더 간결하고 생산적이며 안전한 언어를 제공하는 것이다.
    코틀린은 서버 및 안드로이드에서 작동할 수 있다.
    뿐만아니라 코틀린으로 작성한 코드를 자바뿐만 아니라 자바스크립트로도 컴파일 할 수 있다.
    
### 정적 타입 언어
    코틀린은 정적 타입 언어이지만 자바와 달리 모든 변수의 타입을 프로그래머가 직접 명시할 필요가 없다.
    대부분의 경우 코틀린 컴파일러가 문맥으로부터 변수 타입을 추론하기 때문에 타입의 생략이 가능하다.
    예를 들어 코틀린에서는 아래와 같이 변수를 선언한다.
    
```kotlin
var x = 1
```    
    
    해당 코드는 변수를 정의하면서 정수 값으로 초기화한다.
    var로 타입을 명시하지않고 선언해도 코틀린은 이 변수의 타입을 문맥을 고려해 Int 임을 자동으로 알아낸다.
    또한 코틀린의 타입 시스템은 자바와 비슷하게 작동하고, 자바에 대해 아는 내요을 코틀린에서도 쉽게 적용할 수 있다.

### 널이 될 수 있는 타입    
    코틀린의 한 가지 중요한 특성은 널이 될 수 있는 타입을 지원한다는 것이다.
    널이 될 수 있는 타입을 지원함에 따라 컴파일 시점에 널 포인터 예외가 발생할 수 있는지 여부를 검사할 수 있다.
    자바에서 NullPointerException을 일으키는 유형의 코드는 대부분 코틀린에서는 컴파일도 되지 않는다.


### 함수형 프로그래밍과 객체지향 프로그래밍
    코틀린은 함수형 프로그래밍을 지원하고 함수형 프로그래밍을 사용하면 아래와 같은 장점이 있다.
    
    첫째로 함수형 스타일로 프로그램을 작성하면 간결하게 코드를 작성할 수 있다.
    함수를 값처럼 활용해 더 강력한 추상화를 이뤄 코드의 중복을 막을 수 있다.
    
    둘쨰로 다중 스레들르 사용해도 안전하다.
    다중 스레드 프로그램에서는 적절한 동기화 없이 같은 데이터를 여러 스레드가 변경하는 경우 문제가 생기는데
    불변 데이터 구조를 사용하고 순수 함수를 그 데이터 구조에 적용한다면, 다중 스레드 환경에서
    같은 데이터를 여러 스레드가 변경할 수 없다.
    
    마지막으로 테스트하기가 쉽다.
    
    즉 코틀린을 사용하면 객체지향과 함수형 접근 방법을 함께 조합해서 적합한 코드를 작성할 수 있다.
    
    
    

## 코틀린의 철학    


