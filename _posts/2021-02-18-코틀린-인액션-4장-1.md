---
title: "코틀린 인액션 4장 - 1"
categories: 
  - kotlin
last_modified_at: 2021-02-18T23:00:00+09:00
---

## 클래스 계층 정의
### 코틀린 인터페이스
- 인터페이스는 interface를 사용하여 정의한다.
- 추상 메소드와 구현이 있는 자바의 default 메소드 정의 가능하지만, 필드를 가질 수 없다.
{: style="font-size: 80%;"}

```kotlin
interface Clickable {
    fun click()
}
```

코틀린에서는 클래스 이름 뒤에 콜론(:)을 붙이고 인터페이스와 클래스 이름을 적는 것으로 클래스 확장과 인터페이스 구현을 모두 처리한다.
{: style="font-size: 80%;"}

```kotlin
interface Clickable {
    fun click()
}

class Button : Clickable {
    override fun click() = println("Button clicked")
}

fun main(args: Array<String>) {
    val button: Clickable = Button()
    button.click() // Button clicked
}
```

인터페이스는 원하는 만큼 제한 없이 구현할 수 있지만, 클래스는 오직 하나만 상속받을 수 있다.<br>
또한 코틀린에서는 자바와 달리 메소드를 오버라이드할 때 override 변경자를 꼭 사용해야 한다.
{: style="font-size: 80%;"}


```kotlin
interface Clickable {
    fun showOff() = println("I'm clickable")
}

class Button : Clickable {
}

fun main(args: Array<String>) {
    val button: Clickable = Button()
    button.showOff() // I'm clickable
}
```

인터페이스의 default 메소드는 자바와 달리 메소드 앞에 default 키워드를 붙일 필요없이 그냥 메소드를 구현하면 된다.<br>
{: style="font-size: 80%;"}

```kotlin
interface Clickable {
    fun click()
}

interface Test {
    fun click()
}

class Button : Clickable, Test {
    override fun click() = println("Hello World")
}

fun main(args: Array<String>) {
    val button: Clickable = Button()
    button.click() // "Hello World"
}
```

만약 위처럼 한 클래스에서 두개의 인터페이스를 구현할 때, 두 인터페이스의 추상 메소드가 이름과 시그니처가 같다면
구현 클래스에서는 어느 인터페이스의 메소드를 구현하는 것일까?
{: style="font-size: 80%;"}

> 컴파일러는 이름과 시그니처가 같으면 두 메소드를 동등하게 인식해서 구분하지 않는다.  
{: style="font-size: 80%;"}
- [stackoverflow](https://stackoverflow.com/questions/2801878/implementing-two-interfaces-in-a-class-with-same-method-which-interface-method)

```kotlin
interface Clickable {
    fun showOff() = println("I'm focusable")
}

interface Test {
    fun showOff() = println("I'm testable")
}

class Button : Clickable, Test {
    
}

fun main(args: Array<String>) {
    val button: Clickable = Button()
    button.showOff() // 컴파일 오류
}
```

그렇다면 위처럼 두 인터페이스의 default 메소드의 이름이 같다면 구현 클래스에서는 어느 showOff 메소드가 선택될까?<br>
default 메소드라고해서 위와 같이 사용한다면 컴파일 오류가 발생한다. 이런 경우 showOff 메소드 구현을 대체할
오버라이딩 메소드를 제공해야 한다.
{: style="font-size: 80%;"}

```kotlin
interface Clickable {
    fun showOff() = println("I'm focusable")
}

interface Test {
    fun showOff() = println("I'm testable")
}

class Button : Clickable, Test {
    override fun showOff(){
        super<Clickable>.showOff() // Clickable의 showOff()만 호출
        super<Test>.showOff() // Test의 showOff()만 호출 
        // 혹은 둘 다 호출
        // 혹은 새로운 구현
    }    
}

fun main(args: Array<String>) {
    val button: Clickable = Button()
    button.showOff() // 컴파일 오류
}
```

위와 같이 두 메소드를 아우르는 새로운 구현을 하위 클래스에 직접 구현해야 한다.<br>
즉 위처럼 "super<인터페이스>.메소드()"로 상위 타입의 멤버 메소드를 직접 호출하는 식으로 showOff()를 구현해야 한다.
{: style="font-size: 80%;"}

### open, final, abstract 변경자: 기본적으로 final
    



    
