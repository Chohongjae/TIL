---
title: "코틀린 기초 - 2(작성중)"
categories: 
  - kotlin
last_modified_at: 2021-02-09T23:00:00+09:00
---

## 클래스와 프로퍼티
    코틀린을 활용하면 자바보다 더 적은 양의 코드로 클래스와 관련있는 대부분의 작업을 수행할 수 있다.
    간단한 자바빈 Person 클래스를 정의하자.

```java
public class Person {
    private final String name;
   
    public Person(String name) {
        this.name = name;
    }
    
    public String getName() {
        return this.name;
    }
}
```  

    위의 자바 Person 클래스를 코틀린으로 변환해보자.
    
```kotlin
class Person(val name: String)
```    

    이처럼 코틀린에서는 필드 대입 로직등을 훨씬 더 적은 코드로 작성할 수 있다.
    코틀린의 기본 가시성은 public 이므로 자바에서 작성한 public 접근 제어자가 사라졌다.
    
### 프로퍼티
    자바에서는 보통 데이터를 필드에 저장하며, 멤버 필드의 가시성은 private으로 지정하고, 접근자 메소드(getter/setter)를 제공한다.
    필드와 접근자를 묶어 프로퍼티라고 하며, 코틀린은 프로퍼티를 언어 기본으로 제공한다.
    
```kotlin
class Person(
    val name: String, // 비공개 필드, getter만 제공, 생성자로 필드 초기화
    var isMarried: Boolean // 비공개 필드, getter/setter 제공, 생성자로 필드 초기화     
)
```            

    코틀린은 값을 저장하기 위한 비공개 필드와 그 필드에 값을 저장하기 위한 setter,
    필드의 값을 읽기 위한 getter로 이뤄진 간단한 디폴트 접근자 구현을 제공한다.
    
```java
Person person = new Person("홍제", true)
System.out.println(person.getName())
System.out.println(person.isMarried())
System.out.println(person.setMarried())
``` 
    
```kotlin
val person = Person("홍제", true) // new 키워드를 사용하지 않고 생성자를 호출한다(파이썬과 같다)
println(person.name) // 프로퍼티 이름을 직접 사용해도 코틀린이 자동으로 게터를 호출해준다.
println(person.isMarried) // 프로퍼티 이름을 직접 사용해도 코틀린이 자동으로 게터를 호출해준다.
```
   
    코틀린에서는 게터를 호출하는 대신 프로퍼티를 직접 사용했다.
    세터도 마찬가지로 작동한다. 자바에서는 person.setMarried(true) 로 값을 변경하지만,
    코틀린에서는 person.isMarried = false로 값을 변경한다.
    
### 커스텀 접근자
    직사각형 클래스인 Rectangle을 정의하면서 자신이 정사각형인지 알려주는 프로퍼티 접근자를 직접 작성해보자.
    별도의 필드에 저장하지 않고 너비와 높이가 같은지 검사하면 그때그때 알 수 있다.

```kotlin
class Rectangle(val height: Int, val width: Int) {
    val isSquare: Boolean
        get() { // 프로퍼티 게터 선언
            return height == width
        }
    
    val isSquare2: Boolean 
        get() = height == width // 식을 본문으로 하는 구문
}

val rectangle = Rectangle(3, 5)
println(rectangle.isSquare)
println(rectangle.isSquare2)
```

    isSquare 프로퍼티에는 값을 저장하는 필드가 필요 없고 자체 구현을 제공하는 getter만 존재한다.    
    
    **파라미터가 없는 함수를 정의하는 방식과 커스텀 게터를 정의하는 방식 모두 비슷하다. 
    구현이나 성능상 차이는 없고 차이가 나는 부분은 가독성 뿐이다.(p.74)
    
### 디렉터리와 패키지
    
    
## enum과 when
### enum 클래스
- 색을 표현하는 enum을 코틀린으로 정의해보자.
{: style="font-size: 80%;"}

```kotlin
enum class Color {
    RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, VIOLET
}
```    

    자바와 마찬가지로 enum은 단순히 값만 열거하는 존재가 아니라, 프로퍼티나 메소드를 정의할 수 있다.
    
```kotlin
enum class Color(
    val r: Int, val g: Int, val b: Int // 상수의 프로퍼티를 정의한다.
) {
    RED(255,0,0), ORANGE(255,165,0), // 상수를 생성할 때 그에 대한 프로퍼티 값을 지정한다.
    YELLOW(255,255,0), GREEN(0,255,0); // 코틀린에서 유일하게 세미콜론을 사용해야 한다.
    
    fun rgb() = (r*256 + g) * 256 + b // 메소드를 정의할 수 있다.
}

println(Color.RED.rgb())
```    

### when으로 enum 클래스 다루기
- 코틀린의 when은 자바의 switch를 대치하되 훨씬더 강력하며 자주 사용할 프로그래밍 요소이다.
{: style="font-size: 80%;"}

```text    
if 와 마찬가지로 when도 값을 만들어내는 식이다. 따라서 식이 본문인 함수에 when을 바로 사용할 수 있다.
```

```kotlin
fun getMnemonic(color: Color) = 
    when(color) {
    Color.RED, Color.ORANGE -> "warm"
    Color.YELLOW, Color.GREEN -> "neutral"
    else -> throw Exception("nothing") // 매칭되는 분기 조건이 없으면 이 문장을 실행한다. 자바의 default
}

println(getMnemonic(Color.RED)) // Richard
```    

    color로 전달된 값과 같은 분기를 찾는다.
    자바와 달리 각 분기의 끝에 break를 넣지 않아도 되고, 한 분기 안에서 여러 값을 매치 패턴으로 사용할 수 있다.
    (자바 14부터는 -> 표현으로 break가 필요없다.)
    
### 인자 없는 when 사용
    분기 조건에 숫자, 문자열, enum만을 사용할 수 있는 자바의 switch와 달리 코틀린 when의 분기 조건은 임의의 객체를 허용한다.
    
```kotlin
fun mix(color1: Color, color2: Color) = 
    when (setOf(c1, c2)) {
    setOf(RED, YELLOW) -> ORANGE
    setOf(YELLOW, BLUE) -> GREEN
    else -> throw Exception("nothing") // 매칭되는 분기 조건이 없으면 이 문장을 실행한다. 자바의 default
}

println(mix(BLUE, YELLOW)) // Color.GREEN
```  

    코틀린 표준 라이브러리에 있는 인자로 전달받은 여러 객체를 집합 Set 객체로 만드는 setOf 라는 함수가 있다.
    이처럼 when의 분기 조건 부분에 식을 넣을 수 있기 때문에 코드를 더 간결하게 작성할 수 있다.
    
    하지만 위에서 작성한 함수는 호출될 때마다 분기 조건을 만족하지 못할수록 여러 Set 인스턴스를 생성한다.
    이럴경우 불필요한 가비지 객체가 늘어나게 된다.
    인자가 없는 when식을 사용하면 가독성이 안좋아지지만 불필요한 객체 생성을 막을 수 있다. 
    
```kotlin
fun mix(color1: Color, color2: Color) = 
    when {
    (c1 == RED && c2 == YELLOW || c1 == YELLOW && c2 == RED) -> ORANGE
    (c1 == YELLOW && c2 == BLUE || c1 == BLUE && c2 == YELLOW) -> GREEN 
    else -> throw Exception("nothing") // 매칭되는 분기 조건이 없으면 이 문장을 실행한다. 자바의 default
}

println(mix(BLUE, YELLOW)) // Color.GREEN
```      

> when에 아무 인자도 없으려면 각 분기의 조건이 불리언 결과를 계산하는 식이어야 한다.
    
    
    
    
    
    
        

    
         
    
        
    
    